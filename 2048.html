<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2048 Puzzle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap");
      body {
        font-family: "Inter", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background-color: #1a202c;
        color: #e2e8f0;
        margin: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 2rem;
      }
      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #2d3748;
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        max-width: 400px;
        width: 90%;
      }
      .header {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      h1 {
        font-size: 2.5rem;
        font-weight: 700;
        color: #ffffff;
      }
      .score-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0.5rem 1rem;
        background-color: #4a5568;
        border-radius: 0.5rem;
      }
      .score-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #cbd5e0;
      }
      .score-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: #ffffff;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.5rem;
        width: 100%;
        background-color: #4a5568;
        padding: 0.5rem;
        border-radius: 0.5rem;
      }
      .cell {
        width: 100%;
        padding-top: 100%; /* Makes cells square */
        background-color: #718096;
        border-radius: 0.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .tile {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        font-weight: 700;
        border-radius: 0.5rem;
        transition: transform 0.2s ease-in-out, background-color 0.2s,
          color 0.2s;
      }
      /* Tile colors */
      .tile-2 {
        background-color: #eee4da;
        color: #776e65;
      }
      .tile-4 {
        background-color: #ede0c8;
        color: #776e65;
      }
      .tile-8 {
        background-color: #f2b179;
        color: #f9f6f2;
      }
      .tile-16 {
        background-color: #f59563;
        color: #f9f6f2;
      }
      .tile-32 {
        background-color: #f67c5f;
        color: #f9f6f2;
      }
      .tile-64 {
        background-color: #f65e3b;
        color: #f9f6f2;
      }
      .tile-128 {
        background-color: #edcf72;
        color: #f9f6f2;
      }
      .tile-256 {
        background-color: #edcc61;
        color: #f9f6f2;
      }
      .tile-512 {
        background-color: #edc850;
        color: #f9f6f2;
      }
      .tile-1024 {
        background-color: #edc53f;
        color: #f9f6f2;
      }
      .tile-2048 {
        background-color: #edc22e;
        color: #f9f6f2;
      }
      .tile-4096 {
        background-color: #3e81a3;
        color: #f9f6f2;
      }
      .tile-8192 {
        background-color: #2e6b8c;
        color: #f9f6f2;
      }

      .button {
        background-color: #4a90e2;
        color: #ffffff;
        font-weight: 700;
        padding: 0.75rem 2rem;
        border-radius: 9999px;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-top: 1rem;
      }
      .button:hover {
        background-color: #5d9cec;
      }

      .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #2d3748;
        padding: 2rem;
        border-radius: 1rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        text-align: center;
        z-index: 100;
        display: none;
        flex-direction: column;
        gap: 1rem;
      }
      .message-box h2 {
        font-size: 2rem;
        font-weight: 700;
        color: #ffffff;
      }
      .message-box button {
        background-color: #63b3ed;
        color: #1a202c;
        padding: 0.75rem 2rem;
        border-radius: 9999px;
        border: none;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .message-box button:hover {
        background-color: #90cdf4;
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-100">
    <div class="game-container">
      <div class="header">
        <h1>2048</h1>
        <div class="score-container">
          <div class="score-label">SCORE</div>
          <div class="score-value" id="score">0</div>
        </div>
      </div>
      <div class="grid" id="gameGrid"></div>
      <button id="newGameBtn" class="button">New Game</button>
    </div>

    <div id="messageBox" class="message-box">
      <h2 id="messageTitle"></h2>
      <button id="playAgainBtn" class="button">Play Again</button>
    </div>

    <script>
      const gridElement = document.getElementById("gameGrid");
      const scoreElement = document.getElementById("score");
      const newGameBtn = document.getElementById("newGameBtn");
      const messageBox = document.getElementById("messageBox");
      const messageTitle = document.getElementById("messageTitle");
      const playAgainBtn = document.getElementById("playAgainBtn");

      let grid = [];
      let score = 0;
      let isGameOver = false;

      const gridSize = 4;

      // Tile colors and text colors
      const tileColors = {
        2: "#eee4da",
        4: "#ede0c8",
        8: "#f2b179",
        16: "#f59563",
        32: "#f67c5f",
        64: "#f65e3b",
        128: "#edcf72",
        256: "#edcc61",
        512: "#edc850",
        1024: "#edc53f",
        2048: "#edc22e",
        4096: "#3e81a3",
        8192: "#2e6b8c",
      };
      const textColor = {
        2: "#776e65",
        4: "#776e65",
        8: "#f9f6f2",
        16: "#f9f6f2",
        32: "#f9f6f2",
        64: "#f9f6f2",
        128: "#f9f6f2",
        256: "#f9f6f2",
        512: "#f9f6f2",
        1024: "#f9f6f2",
        2048: "#f9f6f2",
        4096: "#f9f6f2",
        8192: "#f9f6f2",
      };

      const createTile = (value) => {
        const tile = document.createElement("div");
        tile.classList.add("tile");
        tile.textContent = value;
        tile.style.backgroundColor = tileColors[value] || "#818181";
        tile.style.color = textColor[value] || "#e2e8f0";
        return tile;
      };

      const createGrid = () => {
        gridElement.innerHTML = "";
        for (let i = 0; i < gridSize * gridSize; i++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          gridElement.appendChild(cell);
        }
      };

      const drawGrid = () => {
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            const cellIndex = r * gridSize + c;
            const cell = gridElement.children[cellIndex];
            cell.innerHTML = "";
            if (grid[r][c] !== 0) {
              cell.appendChild(createTile(grid[r][c]));
            }
          }
        }
        scoreElement.textContent = score;
      };

      const generateRandomTile = () => {
        if (!hasEmptyCells()) return;
        let r, c;
        do {
          r = Math.floor(Math.random() * gridSize);
          c = Math.floor(Math.random() * gridSize);
        } while (grid[r][c] !== 0);
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      };

      const newGame = () => {
        isGameOver = false;
        score = 0;
        grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
        createGrid();
        generateRandomTile();
        generateRandomTile();
        drawGrid();
        messageBox.style.display = "none";
      };

      const filterZero = (row) => row.filter((tile) => tile !== 0);

      const slide = (row) => {
        let filteredRow = filterZero(row);
        let missing = gridSize - filteredRow.length;
        let zeros = Array(missing).fill(0);
        return zeros.concat(filteredRow);
      };

      const combine = (row) => {
        for (let i = gridSize - 1; i > 0; i--) {
          if (row[i] === row[i - 1]) {
            row[i] *= 2;
            score += row[i];
            row[i - 1] = 0;
          }
        }
        return row;
      };

      const slideAndCombine = (row) => {
        let newRow = slide(row);
        newRow = combine(newRow);
        newRow = slide(newRow);
        return newRow;
      };

      const moveRight = () => {
        let changed = false;
        for (let r = 0; r < gridSize; r++) {
          let originalRow = [...grid[r]];
          let newRow = slideAndCombine(grid[r]);
          if (JSON.stringify(originalRow) !== JSON.stringify(newRow)) {
            changed = true;
          }
          grid[r] = newRow;
        }
        return changed;
      };

      const moveLeft = () => {
        let changed = false;
        for (let r = 0; r < gridSize; r++) {
          let originalRow = [...grid[r]];
          let newRow = slideAndCombine(grid[r].reverse()).reverse();
          if (JSON.stringify(originalRow) !== JSON.stringify(newRow)) {
            changed = true;
          }
          grid[r] = newRow;
        }
        return changed;
      };

      const transpose = () => {
        let newGrid = Array.from({ length: gridSize }, () =>
          Array(gridSize).fill(0)
        );
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            newGrid[r][c] = grid[c][r];
          }
        }
        grid = newGrid;
      };

      const moveUp = () => {
        transpose();
        let changed = moveLeft();
        transpose();
        return changed;
      };

      const moveDown = () => {
        transpose();
        let changed = moveRight();
        transpose();
        return changed;
      };

      const hasEmptyCells = () => {
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            if (grid[r][c] === 0) return true;
          }
        }
        return false;
      };

      const hasPossibleMoves = () => {
        if (hasEmptyCells()) return true;
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            if (c < gridSize - 1 && grid[r][c] === grid[r][c + 1]) return true;
            if (r < gridSize - 1 && grid[r][c] === grid[r + 1][c]) return true;
          }
        }
        return false;
      };

      const checkGameOver = () => {
        if (!hasPossibleMoves()) {
          isGameOver = true;
          messageTitle.textContent = "Game Over!";
          messageBox.style.display = "flex";
        }
      };

      const handleMove = (direction) => {
        if (isGameOver) return;
        let changed = false;
        switch (direction) {
          case "right":
            changed = moveRight();
            break;
          case "left":
            changed = moveLeft();
            break;
          case "up":
            changed = moveUp();
            break;
          case "down":
            changed = moveDown();
            break;
        }
        if (changed) {
          generateRandomTile();
          drawGrid();
          checkGameOver();
        }
      };

      // Event listeners for keyboard
      document.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            handleMove("right");
            break;
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            handleMove("left");
            break;
          case "ArrowUp":
          case "w":
          case "W":
            e.preventDefault();
            handleMove("up");
            break;
          case "ArrowDown":
          case "s":
          case "S":
            e.preventDefault();
            handleMove("down");
            break;
        }
      });

      // Event listeners for touch (swipe)
      let touchstartX = 0;
      let touchendX = 0;
      let touchstartY = 0;
      let touchendY = 0;

      const handleGesture = () => {
        if (
          Math.abs(touchendX - touchstartX) > Math.abs(touchendY - touchstartY)
        ) {
          if (touchendX < touchstartX) handleMove("left");
          if (touchendX > touchstartX) handleMove("right");
        } else {
          if (touchendY < touchstartY) handleMove("up");
          if (touchendY > touchstartY) handleMove("down");
        }
      };

      gridElement.addEventListener(
        "touchstart",
        (e) => {
          touchstartX = e.changedTouches[0].screenX;
          touchstartY = e.changedTouches[0].screenY;
        },
        false
      );

      gridElement.addEventListener(
        "touchend",
        (e) => {
          touchendX = e.changedTouches[0].screenX;
          touchendY = e.changedTouches[0].screenY;
          handleGesture();
        },
        false
      );

      newGameBtn.addEventListener("click", newGame);
      playAgainBtn.addEventListener("click", newGame);

      window.onload = newGame;
    </script>
  </body>
</html>

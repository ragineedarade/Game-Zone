<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Physics Playground</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        @apply bg-gray-900 text-gray-100 flex flex-col justify-center items-center min-h-screen py-8;
      }
      .container {
        @apply bg-gray-800 p-6 rounded-2xl shadow-2xl flex flex-col items-center space-y-6 max-w-full;
      }
      canvas {
        @apply rounded-xl border-4 border-teal-500/50 cursor-crosshair;
      }
      .action-button {
        @apply bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="text-3xl font-bold text-teal-400">Physics Playground</h1>
      <p class="text-gray-400 text-center max-w-sm">
        Click and drag your mouse to create shapes that fall and bounce in a
        simulated world.
      </p>
      <!-- Canvas for the physics simulation -->
      <canvas id="renderCanvas"></canvas>
      <button id="clearButton" class="action-button">Clear Shapes</button>
    </div>

    <script>
      window.onload = function () {
        // Module aliases
        const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Mouse = Matter.Mouse,
          MouseConstraint = Matter.MouseConstraint;

        // Get the canvas element and its parent container
        const renderCanvas = document.getElementById("renderCanvas");
        const container = document.querySelector(".container");
        const clearButton = document.getElementById("clearButton");

        // Set canvas size based on window dimensions
        let canvasWidth = Math.min(600, window.innerWidth - 40);
        let canvasHeight = Math.min(400, window.innerHeight - 120);
        renderCanvas.width = canvasWidth;
        renderCanvas.height = canvasHeight;

        // Create a Matter.js engine
        const engine = Engine.create();
        const world = engine.world;

        // Create a renderer
        const render = Render.create({
          element: container,
          canvas: renderCanvas,
          engine: engine,
          options: {
            width: canvasWidth,
            height: canvasHeight,
            wireframes: false,
            background: "#1f2937", // gray-800 equivalent
          },
        });

        // Create static ground and walls
        const ground = Bodies.rectangle(
          canvasWidth / 2,
          canvasHeight - 20,
          canvasWidth,
          40,
          { isStatic: true, render: { fillStyle: "#4b5563" } }
        );
        const wallLeft = Bodies.rectangle(
          20,
          canvasHeight / 2,
          40,
          canvasHeight,
          { isStatic: true, render: { fillStyle: "#4b5563" } }
        );
        const wallRight = Bodies.rectangle(
          canvasWidth - 20,
          canvasHeight / 2,
          40,
          canvasHeight,
          { isStatic: true, render: { fillStyle: "#4b5563" } }
        );

        // Add the static bodies to the world
        Composite.add(world, [ground, wallLeft, wallRight]);

        // Add a mouse constraint for interactivity
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
          mouse: mouse,
          constraint: {
            stiffness: 0.2,
            render: {
              visible: false,
            },
          },
        });

        Composite.add(world, mouseConstraint);

        // Keep the renderer in sync with the mouse
        render.mouse = mouse;

        // Variables for creating shapes
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };

        // Mouse down event to start drawing
        document.addEventListener("mousedown", function (event) {
          if (event.target === renderCanvas) {
            isDragging = true;
            startPoint.x = event.offsetX;
            startPoint.y = event.offsetY;
          }
        });

        // Mouse up event to finish drawing and create the shape
        document.addEventListener("mouseup", function (event) {
          if (isDragging && event.target === renderCanvas) {
            isDragging = false;
            const endPoint = { x: event.offsetX, y: event.offsetY };
            const shapeType = Math.random() > 0.5 ? "circle" : "rectangle";

            let newBody;
            if (shapeType === "circle") {
              const radius =
                Math.sqrt(
                  Math.pow(endPoint.x - startPoint.x, 2) +
                    Math.pow(endPoint.y - startPoint.y, 2)
                ) / 2;
              newBody = Bodies.circle(
                startPoint.x + (endPoint.x - startPoint.x) / 2,
                startPoint.y + (endPoint.y - startPoint.y) / 2,
                radius,
                {
                  render: {
                    fillStyle: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    strokeStyle: "#ffffff",
                    lineWidth: 2,
                  },
                }
              );
            } else {
              const width = Math.abs(endPoint.x - startPoint.x);
              const height = Math.abs(endPoint.y - startPoint.y);
              newBody = Bodies.rectangle(
                startPoint.x + (endPoint.x - startPoint.x) / 2,
                startPoint.y + (endPoint.y - startPoint.y) / 2,
                width,
                height,
                {
                  render: {
                    fillStyle: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    strokeStyle: "#ffffff",
                    lineWidth: 2,
                  },
                }
              );
            }
            Composite.add(world, newBody);
          }
        });

        // Clear button functionality
        clearButton.addEventListener("click", function () {
          // Remove all non-static bodies from the world
          const bodiesToRemove = world.bodies.filter((body) => !body.isStatic);
          Composite.remove(world, bodiesToRemove);
        });

        // Run the engine and the renderer
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Resize event listener for responsive canvas
        window.addEventListener("resize", function () {
          canvasWidth = Math.min(600, window.innerWidth - 40);
          canvasHeight = Math.min(400, window.innerHeight - 120);

          // Update canvas dimensions
          render.canvas.width = canvasWidth;
          render.canvas.height = canvasHeight;

          // Update world bounds and static bodies
          Matter.Body.setPosition(ground, {
            x: canvasWidth / 2,
            y: canvasHeight - 20,
          });
          Matter.Body.setPosition(wallLeft, { x: 20, y: canvasHeight / 2 });
          Matter.Body.setPosition(wallRight, {
            x: canvasWidth - 20,
            y: canvasHeight / 2,
          });

          // You can also clear all dynamic bodies here
          const bodiesToRemove = world.bodies.filter((body) => !body.isStatic);
          Composite.remove(world, bodiesToRemove);
        });
      };
    </script>
  </body>
</html>
